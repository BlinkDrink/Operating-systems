https://drive.google.com/file/d/1W7nO7o6HdBlX7_W8NHI7whcoSU3bO4MU/view?usp=share_link

###  Template
	#include <stdio.h>
	#include <err.h>
	#include <fcntl.h>
	#include <stdlib.h>
	#include <unistd.h>
	#include <stdint.h>
	#include <sys/types.h>
	#include <sys/stat.h>
	#include <string.h>
	int main (const int argc,const char * argv[]) 
	{
	}

### 54. 2016-SE-01 Idea - Counting sort [0..255]

	#include <fcntl.h> 
	#include <stdio.h>
	#include <err.h>
	#include <unistd.h>
	#include <stdint.h>
	int main(int argc, char* argv[])
	{
	        if (argc != 3)
	        {
	                errx(1, "Error: not enough args");
	        }
	        int fd1,fd2;
		    fd1 = open(argv[1], O_RDONLY);
	        if (fd1 == -1)
	        {
	                err(2,"Couldnt open %s for reading",argv[1]);
	        }

	        ssize_t count_sort[UINT8_MAX+1]={0,};
	        ssize_t read_size;
	        uint8_t b;
	        while((read_size=read(fd1,&b,1)) > 0)
	        {
	                count_sort[b]++;
	        }

	        if(read_size == -1)
	        {
	                err(5,"err");
	        }

	        fd2 = creat(argv[2],S_IRUSR | S_IWUSR);
	        if (fd2 == -1)
	        {
	                err(3,"Couldnt open %s for reading/writing", argv[2]);
	        }

	        for(uint8_t i = 0; i < UINT8_MAX; i++)
	        {
	                for (ssize_t j = 0; j < count_sort[i];j++)
	                {
	                        if(write(fd2,&i,1) != 1)
	                        {
	                                err(4, "There was error reading %c", i);
	                        }
	                }
	        }
	        return 0;
	}


### 55. 2016-SE-02 
	#include<stdint.h>
	#include <unistd.h>
	#include <fcntl.h>
	#include <err.h>
	#include <stdio.h>

	struct interval_m
	{
	        uint32_t begin;
	        uint32_t length;
	};

	int main (const int argc,const char* argv[])
	{
	        if (argc != 3)
	        {
	                errx(2,"args not enough");
	        }
	        int fd1= open(argv[1], O_RDONLY);
	        if (fd1 == -1)
	        {
	                err(1,"err opening fd1");
	        }

	        int fd2 = open(argv[2], O_RDONLY);
	        if (fd2 == -1)
	        {
	                err(4,"couldnt open file2 for reading");
	        }

	        int fd3 = creat("result",S_IRUSR | S_IWUSR);

	        uint32_t buf;
	        ssize_t read_size,read_size2;
	        struct interval_m interval;
	        while ((read_size=read(fd1, &interval,sizeof(interval)))== sizeof(interval))
	        {
	                printf("%d %d", interval.begin, interval.length);
	                if(lseek(fd2,interval.begin, SEEK_SET) == -1)
	                {
	                        err(3,"There was error setting pointer in fd2");
	                }

	                for(size_t i=0;i<interval.length;i++)
	                {
	                        read_size2=read(fd2,&buf,sizeof(buf));

	                        if(read_size2 == -1)
	                        {
	                                err(5,"Couldnt read from file2");
	                        }
	                        else if (read_size2 != sizeof(buf))
	                        {
	                                err(6,"there was difference in the read bytes and the expected read bytes");
	                        }

	                        if(write(fd3, &buf, sizeof(buf)) != sizeof(buf))
	                        {
	                                err(7, "couldnt write to result file");
	                        }
	                }
	        }

	        if(read_size == -1) { err (8, "reading from file1 has failed");}
	        else if (read_size > 0) { err(9,"file1 reading error");}

	        return 0;
}

### 56. 2016-SE-03 Idea - Get  the first 50 000 000 binary numbers -> sort them -> write them to a tmp_1 file. Then get the other 50 000 000 -> sort them -> do merge sort on the tmp_1 file and the currently sorted array
	#include <stdio.h>
	#include <err.h>
	#include <fcntl.h>
	#include <stdlib.h>
	#include <unistd.h>
	#include <stdint.h>
	#include <sys/types.h>
	#include <sys/stat.h>

	static int mycmp(const void *left, const void *right)
	{

	        if(*(const uint32_t *)left == *(const uint32_t *)right)
	        {
	                return 0;
	        }
	        else if(*(const uint32_t *)left > *(const uint32_t *)right)
	        {
	                return 1;
	        }
	        else
	        {
	                return -1;
	        }

	}

	int main(const int argc, const char* argv[]){
	        if(argc != 2) { errx(1,"not enough args"); }
	        int fd1,fd2,fd3,fd4;
	        fd1=open(argv[1],O_RDONLY);
	        fd2=open("sorted",S_IRUSR | S_IWUSR);
	        fd3=creat("tmp", S_IRUSR | S_IWUSR);
	        fd4=creat("tmp2",S_IRUSR | S_IWUSR);
	        if (fd1 == -1 || fd2 == -1 || fd3 == -1 || fd4 == -1)
	        {
	                err(2,"Error opening fd1 or fd2 for read/write");
	        }

	        uint32_t buff[50000000];
	        ssize_t readsize,readsize2;
	        readsize=read(fd1,&buff,sizeof(buff));
	        if(readsize==-1 || readsize != sizeof(buff)){ err(3,"error reading from fd1 on first half");}
	        qsort(buff,sizeof(buff),sizeof(uint32_t),mycmp);
	        if(write(fd3, &buff, sizeof(buff)) != sizeof(buff))
	        {
	                err(4,"error writing first half to fd3");
	        }

	        if((readsize2= read(fd1,&buff,sizeof(buff))) == -1)
	        {
	                err(5,"err reading second half from fd1");
	        }

	        qsort(buff, sizeof(buff),sizeof(uint32_t),mycmp);
	        if(write(fd4,&buff,sizeof(buff))!= sizeof(buff))
	        {
	                err(6,"error writing to fd4 second half");
	        }

	        lseek(fd3,0,SEEK_SET);
	        lseek(fd4,0,SEEK_SET);

	        uint32_t left,right;
	        while((readsize=read(fd3,&left,sizeof(left))>0 && (readsize2=read(fd4,&right,sizeof(right)))>0 ))
	        {
	                if(left < right)
	                {
	                        if(write(fd2,&left, sizeof(left))!= sizeof(left))
	                        {
	                                err(7,"error writing to the sorted file");
	                        }
	                        if((readsize=read(fd3,&left,sizeof(left))) == -1)
	                        {
	                                err(8,"error reading from fd3 (left)");
	                        }
	                        if(readsize != sizeof(left))
	                        {
	                                err(9, "bytes read differ from expected bytes to read");
	                        }

	                        while(left < right)
	                        {
	                                if(write(fd2,&left, sizeof(left))!= sizeof(left))
	                                {
	                                        err(7,"error writing to the sorted file");
	                                }

	                                if((readsize=read(fd3,&left,sizeof(left)))== -1)
	                                {
	                                        err(8, "error reading from fd3 (left)");
	                                }
	                                if(readsize != sizeof(left))
	                                {
	                                        err(9,"bytes read differ from expected bytes to read");
	                                }
	                        }
	                }
	                else
	                {
	                        if(write(fd2,&right,sizeof(right)) != sizeof(right))
	                        {
	                                err(7,"error writing to sorted file");
	                        }

	                        if((readsize2=read(fd4,&right,sizeof(right))==-1))
	                        {
	                                err(10,"error reading from fd4 (right)");
	                        }
	                        if(readsize != sizeof(right))
	                        {
	                                err(11,"bytes read differ from expected bytes to read for fd4");
	                        }

	                        while(right < left)
	                        {
	                                if(write(fd2,&right, sizeof(right))!= sizeof(right))
	                                {
	                                        err(7,"error writing to the sorted file");
	                                }

	                                if((readsize2=read(fd4,&right,sizeof(right)))== -1)
	                                {
	                                        err(10, "error reading from fd4 (right)");
	                                }
	                                if(readsize2 != sizeof(right))
	                                {
	                                        err(11,"bytes read differ from expected bytes to read for fd4");
	                                }
	                        }
	                }
	        }

	        if(readsize > 0)
	        {
	                while((readsize=read(fd3,&left,sizeof(left)))>0)
	                {
	                        if(write(fd2,&left, sizeof(left))!= sizeof(left))
	                        {
	                                err(7,"error writing to the sorted file");
	                        }
	                }
	        }

	        if(readsize2 > 0)
	        {
	                while((readsize2=read(fd4,&right,sizeof(right)))>0)
	                {
	                        if(write(fd2,&right, sizeof(right))!= sizeof(right))
	                        {
	                                err(7,"error writing to the sorted file");
	                        }
	                }
	        }

	        close(fd1);
	        close(fd2);
	        close(fd3);
	        close(fd4);
	        return 0;
	}

### 57. 2017-IN-01 
Идея: четем от .idx файла който са ни дали, като четем sizeof(DAT) на брой байтове. За всяка такава структура бъркаме във първият файл на offset DAT.offset и в динамично заделен масив (buffer) с големина DAT.length четем толкова на брой байтове. Проверяваме дали buffer[0] е главна и ако е главна записваме съответната дума във файл с име <трети подаден аргумент>, а DAT структурата я записваме в файл с име <четвърти подаден аргумент>.

	#include <stdio.h>
	#include <err.h>
	#include <fcntl.h>
	#include <stdlib.h>
	#include <unistd.h>
	#include <stdint.h>
	#include <sys/types.h>
	#include <sys/stat.h>

	struct DAT
	{
	        uint16_t offset;
	        uint8_t  length;
	        uint8_t  saved;
	};

	int main (const int argc,const char * argv[])
	{
	    if(argc != 5)
	    {
	            errx(1,"not enough args");
	    }
        int fd1,fd2,fd3,fd4;
        fd1=open(argv[1], O_RDONLY);
        fd2=open(argv[2], O_RDONLY);
        fd3=creat(argv[3], S_IRUSR | S_IWUSR);
        fd4=creat(argv[4], S_IRUSR | S_IWUSR);

        if(fd1 == -1 || fd2 == -1 || fd3==-1 || fd4==-1)
        {
                err(2,"error opening/creating one of the files");
        }

        int readsize,readsize2;
        struct DAT dat_str;
        struct DAT currDat;
        currDat.offset = 0;
        currDat.length = 0;
        currDat.saved  = 0;

        while((readsize=read(fd2,&dat_str, sizeof(dat_str))) > 0)
        {
                lseek(fd1,dat_str.offset,SEEK_SET);

                uint8_t c;
                uint8_t currLen=dat_str.length;
                if((readsize2 = read(fd1,&c, sizeof(uint8_t)))< 0)
                {
                        err(3,"error reading first char from word");
                }
                currLen--;


                if(c >= 0x41 && c <= 0x5A)
                {
                        if(write(fd3,&c,sizeof(uint8_t)) != sizeof(uint8_t))
                        {
                                err(4,"error writing the upper case letter");
                        }

                        while((readsize2=read(fd1,&c,sizeof(uint8_t))) > 0 && currLen > 0)
                        {
                                if(write(fd3, &c, sizeof(uint8_t)) != sizeof(uint8_t))
                                {
                                        err(5,"Error writing to fd3 of char %u", c);
                                }

                                currLen--;
                        }

                        currDat.length = dat_str.length;
                        currDat.saved  = dat_str.saved;
                        if(write(fd4, &currDat, sizeof(currDat)) != sizeof(currDat))
                        {
                                err(6, "error writing to fd4 of Dat structure: %d %d %d", dat_str.offset, dat_str.length,dat_str.saved);
                        }

                        currDat.offset+=dat_str.length;
                }
        }

        return 0;
	}

	
### 58. 2017-SE-01
	#include <stdio.h>
	#include <err.h>
	#include <fcntl.h>
	#include <stdlib.h>
	#include <unistd.h>
	#include <stdint.h>
	#include <sys/types.h>
	#include <sys/stat.h>

	struct PATCH_STR
	{
	    uint16_t offset;
	    uint8_t originalByte;
	    uint8_t newByte;
	};

	int main (const int argc,const char * argv[])
	{
	    if(argc != 4)
	    {
	         errx(1,"not enough args");
	    }

        int fd1,fd2,fdpatch;
        fd1=open(argv[1], O_RDONLY);
        fd2=open(argv[2], O_RDONLY);
        fdpatch=creat(argv[3], S_IRUSR | S_IWUSR);
        if (fd1 == -1 || fd2 == -1 || fdpatch == -1)
        {
                err(2,"Error opening/creating one of the files");
        }

        uint8_t left,right;
        int readsize,readsize2,counter=0;
        while((readsize=read(fd1,&left,sizeof(left)) >0 && (readsize2=read(fd2,&right,sizeof(right)))> 0))
        {
                if(left != right)
                {
                        struct PATCH_STR strToWrite;
                        strToWrite.offset = counter;
                        strToWrite.originalByte=left;
                        strToWrite.newByte=right;
                        if(write(fdpatch, &strToWrite, sizeof(strToWrite)) != sizeof(strToWrite))
                        {
                                err(3,"error writing the struct to %s", argv[3]);
                        }
                }

                counter++;
        }

        return 0;
	}

### 59. 2017-SE-02
	#include <stdlib.h>
	#include <err.h>
	#include <unistd.h>
	#include <sys/stat.h>
	#include <fcntl.h>
	#include <stdint.h>
	#include <string.h>
	#include <stdio.h>

	enum exit_code
	{
	        ARG_ERR = 1,

	        READ_ERR,
	        WRITE_ERR,
	        OPEN_ERR,
	        OTHER_ERR,
	        CLOSE_ERR
	};

	void rdwr(const int fdrd, const int fdwr, uint8_t enumerate);

	void rdwr(const int fdrd, const int fdwr, uint8_t enumerate)
	{
	        int n = 1;

        char buf;

        char nbuf[256];

        ssize_t rdsz;

        // ???
        if (enumerate == 1)
        {
                sprintf(nbuf, "%d ", n);
                fputs(nbuf, stdout);
                fflush(stdout);
        }

        while ((rdsz = read(fdrd, &buf, 1)) > 0)
        {
                if (write(fdwr, &buf, 1) != 1)
                {
                        err(WRITE_ERR, "writing err");
                }

                // ???
                if (buf == '\n' && enumerate == 1)
                {
                        n++;
                        sprintf(nbuf, "%d ", n);
                        setbuf(stdout, nbuf);
                        fputs(nbuf, stdout);
                        fflush(stdout);
                }
        }

        if (rdsz == -1)
        {
                err(READ_ERR, "reading err");
        }
	}
	
	int main(const int argc, const char* argv[])
	{
	        uint8_t enumerate = 0;

        if (argc == 1)
        {
                rdwr(0, 1, enumerate);
                exit(0);
        }

        if (strcmp(argv[1], "-n") == 0)
        {
                enumerate = 1;
        }

        if (argc == 2 && enumerate == 1)
        {
                rdwr(0, 1, enumerate);
                exit(0);
        }

        int fd;

        int i = (enumerate == 1) ? 2 : 1;

        while (i < argc)
        {
                if (strcmp(argv[i], "-") == 0)
                {
                        fd = 0;
                }
                else if ((fd = open(argv[i], O_RDONLY)) == -1)
                {
                        err(OPEN_ERR, "open err");
                }

                rdwr(fd, 1, enumerate);

                if (fd != 0 && close(fd) == -1)
                {
                        err(CLOSE_ERR, "close err");
                }

                i++;
        }

        exit(0);
	}
### 60. 2017-SE-03

	#include <stdio.h>
	#include <err.h>
	#include <fcntl.h>
	#include <stdlib.h>
	#include <unistd.h>
	#include <stdint.h>
	#include <sys/types.h>
	#include <sys/stat.h>

	struct PATCH_STR
	{
	    uint16_t offset;
	    uint8_t originalByte;
	    uint8_t newByte;
	};

	int main (const int argc,const char * argv[])
	{
	    if(argc != 4)
	    {
	         errx(1,"not enough args");
	    }

	    int fd1,fd2,fdpatch;
	    fd1=open(argv[2], O_RDONLY);
	    fd2=creat(argv[3], S_IRUSR | S_IWUSR);
	    fdpatch=open(argv[1], O_RDONLY);
	    if (fd1 == -1 || fd2 == -1 || fdpatch == -1)
	    {
	            err(2,"Error opening/creating one of the files");
	    }

	    uint8_t f1Byte;
	    int readsize,readsize2;
        uint16_t counter=0;
        struct PATCH_STR patchBin;
	    while((readsize=read(fdpatch, &patchBin, sizeof(patchBin))) != 0)
	    {
                while((readsize2=read(fd1,&f1Byte,sizeof(f1Byte))) != 0)
                {
                        if(counter == patchBin.offset)
                        {
                                if(write(fd2,&patchBin.newByte, sizeof(patchBin.newByte)) != sizeof(patchBin.newByte))
                                {
                                        err(3,"Error writing new byte to f2.bin");
                                }
                                counter++;
                                break;
                        }
                        else
                        {
                                if(write(fd2,&f1Byte,sizeof(f1Byte)) != sizeof(f1Byte))
                                {
                                        err(4,"Error writing old byte to f2.bin");
                                }
                                counter++;
                        }
                }
	    }

        if(readsize < 0 || readsize2 < 0)
        {
                err(5,"error with readsize or readsize2");
        }

        if(readsize2 > 0)
        {
                while((readsize2 = read(fd1,&f1Byte,sizeof(f1Byte))) == sizeof(f1Byte))
                {
                        if(write(fd2,&f1Byte,sizeof(f1Byte)) != sizeof(f1Byte))
                        {
                                err(4,"error writing old byte to f2.bin");
                        }
                }
        }

	    return 0;
	}

### 61 : same as 59 but without "-n"

### 62. 2018-SE-01
	
	#include <stdio.h>
	#include <err.h>
	#include <fcntl.h>
	#include <stdlib.h>
	#include <unistd.h>
	#include <stdint.h>
	#include <sys/types.h>
	#include <sys/stat.h>
	#include <string.h>

	enum OPTIONS
	{
	        NO_OP=0,
	        S_OP=1,
	        D_OP=2,
	};

	int isInArr(const char* word, uint8_t ch);

	int isInArr(const char* word, uint8_t ch)
	{
	        int wordLen = strlen(word);
	        for(int i = 0; i < wordLen; i++)
	        {
	                if(word[i] == ch)
	                {
	                        return 1;
	                }
	        }

        return 0;
	}

	int main (const int argc,const char * argv[])
	{
	    enum OPTIONS opt = NO_OP;
	    if(argc < 2)
	    {
	            errx(1,"not enough args");
	    }

        if(!strcmp(argv[1], "-d") && argc == 3)
        {
                opt = D_OP;
        }
        else if(!strcmp(argv[1], "-s") && argc == 3)
        {
                opt = S_OP;
        }
        else if(strcmp(argv[1],"-s") != 0 && strcmp(argv[1], "-d") != 0 && argc == 3)
        {
                opt = NO_OP;
        }
        else
        {
                err(2,"Arguments mismatch");
        }

        if(opt==NO_OP)
        {
                if(strlen(argv[1]) != strlen(argv[2]))
                {
                        errx(3,"Lengths of arrays mismatch");
                }

                int rdsz;
                uint8_t b;
                while((rdsz=read(0,&b,sizeof(b))) > 0)
                {
                        size_t arr1Size = strlen(argv[1]);
                        uint8_t flag=0;
                        for(ssize_t i = arr1Size; i >= 0; i--)
                        {
                                if(argv[1][i] == b)
                                {
                                        if(write(1, &argv[2][i], sizeof(uint8_t)) != sizeof(uint8_t))
                                        {
                                                err(4,"Error writing to stdout of char %u", argv[2][i]);
                                        }
                                        flag = 1;
                                        break;
                                }
                        }

                        if(!flag)
                        {
                                if(write(1,&b,sizeof(b)) != sizeof(b))
                                {
                                        err(5,"Error writing to stdout of same char %u", b);
                                }
                        }
                }

                if(rdsz < 0)
                {
                        err(4,"Error reading with NO_OPT");
                }
        }
        else if(opt == S_OP)
        {
                uint8_t prev,curr;
                int rdsz,rdsz2;
                if((rdsz=read(0,&prev,sizeof(prev))) < 0)
                {
                        err(6,"Error reading prev the first time");
                }

                if(write(1,&prev,sizeof(prev)) != sizeof(prev))
                {
                        err(7,"error writing the first prev");
                }

                while((rdsz2 = read(0,&curr,sizeof(curr))) > 0)
                {
                        if(curr == prev && isInArr(argv[2],curr))
                        {
                                continue;
                        }
                        else
                        {
                                prev = curr;
                                if(write(1,&curr,sizeof(curr)) != sizeof(curr))
                                {
                                        err(8,"error writing inner curr to the stdout");
                                }
                        }
                }
        }
        else if(opt == D_OP)
        {
                uint8_t curr;
                int rdsz;
                while((rdsz=read(0,&curr,sizeof(curr))) > 0)
                {
                        if(isInArr(argv[2],curr))
                        {
                                continue;
                        }

                        if(write(1,&curr,sizeof(curr)) != sizeof(curr))
                        {
                                err(9,"Error writing curr to stdout in -d mode");
                        }
                }
        }
        else
        {
                errx(10,"Unrecocgnized command!");
        }

        return 0;
	}

### 64. 2018-SE-02

	#include <stdio.h>
	#include <err.h>
	#include <fcntl.h>
	#include <stdlib.h>
	#include <unistd.h>
	#include <stdint.h>
	#include <sys/types.h>
	#include <sys/stat.h>
	#include <string.h>
	enum OPTIONS
	{
	        NO_OP=0,
	        C_OP_range=1,
	        C_OP_only_one=2,
	        D_OP_range=3,
	        D_OP_only_one=4,
	};
	int main (const int argc,const char * argv[])
	{
	        enum OPTIONS opt = NO_OP;
	        if(argc < 3)
	        {
	                errx(1,"Not enough args for cut");
	        }
	        // -c
	        else if(argc == 3 && !strcmp(argv[1],"-c"))
	        {
	                // -c 5
	                if(strlen(argv[2])== 1)
	                {
	                        if(argv[2][0] < 0x30 || argv[2][0] > 0x39)
	                        {
	                                errx(4,"argument given to -c isnt a number");
	                        }
	                        opt = C_OP_only_one;
	                }
	                // -c 3-5
	                else if(strlen(argv[2]) == 3)
	                {
	                        if(argv[2][0] > 0x30 && argv[2][0] < 0x39 && argv[2][1] == 0x2D && argv[2][2] > 0x30 && argv[2][2] < 0x39)
	                        {
	                                opt = C_OP_range;
	                        }
	                        else
	                        {
	                                errx(2,"Check if your -c arg is appropriate. (e.g 3-5)");
	                        }
	                }
	                else
	                {
	                        errx(3,"Check your -c arg input (number of args)");
	                }
	        }
	        // -d
	        else if(argc == 5 && !strcmp(argv[1],"-d"))
	        {
	                if(strcmp(argv[3],"-f"))
	                {
	                        errx(4,"Incorrect cut args. (-f)");
	                }

                // -d ".." -f 1
                if(strlen(argv[4])== 1)
                {
                        opt = D_OP_only_one;
                }
                // -d ".." -f 3-5
                else if(strlen(argv[4]) == 3)
                {
                        if(argv[4][0] > 0x30 && argv[4][0] < 0x39 && argv[4][1] == 0x2D && argv[4][2] > 0x30 && argv[4][2] < 0x39)
                        {
                                if(argv[4][0] == argv[4][2])
                                {
                                        opt=D_OP_only_one;
                                }
                                else
                                {
                                        opt = D_OP_range;
                                }
                        }
                        else
                        {
                                errx(2,"Check if your field arg is appropriate. (e.g 3-5)");
                        }
                }
                else
                {
                        errx(3,"Check your field input (number of args)");
                }
		        }
		        uint8_t c;
		        int currLen,rdsz,left,right;
		        int currDel=1;
		        switch(opt)
		        {
                case C_OP_only_one:
                        //while((rdsz=read(0,&c,sizeof(c))) > 0)
                        //{
                        currLen=atoi(argv[2]);
                        while((rdsz=read(0,&c,sizeof(c))) > 0)
                        {
                                if(currLen == 1)
                                {
                                        if(write(1,&c,sizeof(c)) != sizeof(c))
                                        {
                                                err(5,"error writing only 1 byte in C_OP_only_one (%u)", c);
                                        }
                                        break;
                                }
                                currLen--;
                        }
                        break;
                case C_OP_range:
                        left=atoi(&argv[2][0]);
                        right=atoi(&argv[2][2]);
                        currLen=1;
                        while((rdsz=read(0,&c,sizeof(c))) > 0)
                        {
                                if(currLen >= left && currLen <= right)
                                {
                                        if(write(1,&c,sizeof(c)) != sizeof(c))
                                        {
                                                err(6,"error writing char %u of C_OP_range", c);
                                        }
                                }
                                currLen++;
                        }
                        break;
                case D_OP_only_one:
                        currLen=atoi(&argv[4][0]);
                        while((rdsz=read(0,&c,sizeof(c))) > 0 && currDel <= currLen)
                        {
                                if(c == argv[2][0])
                                {
                                        currDel++;
                                        continue;
                                }
                                if(currDel == currLen)
                                {
                                        if(write(1,&c,sizeof(c)) != sizeof(c))
                                        {
                                                err(7,"ERror writing single char to stdout in C_OP_only_one");
                                        }
                                }
                        }
                        break;
                case D_OP_range:
                        left=atoi(&argv[4][0]);
                        right=atoi(&argv[4][2]);
                        currLen=1;
                        while((rdsz=read(0,&c,sizeof(c))) > 0)
                        {
                                if(c==argv[2][0])
                                {
                                        currDel++;
                                        if(currDel == left)
                                        {
                                                continue;
                                        }
                                }
                                if(currDel >= left && currDel <=right)
                                {
                                        if(write(1,&c,sizeof(c)) != sizeof(c))
                                        {
                                                err(8,"Error writing char for D_OP_range");
                                        }
                                }
                        }
                        break;
                default:
                        errx(10,"No options");
        }
        printf("\n");
        return 0;
	}
### 65. 2018-SE-04
	#include <stdio.h>
	#include <err.h>
	#include <fcntl.h>
	#include <stdlib.h>
	#include <unistd.h>
	#include <stdint.h>
	#include <sys/types.h>
	#include <sys/stat.h>
	#include <string.h>
	int mycmp(const void *left,const void* right);
	int mycmp(const void *left, const void* right)
	{
	        return (*(const uint16_t *)left - *(const uint16_t *)right);
	}
	int main (const int argc,const char * argv[])
	{
	        if(argc != 3)
	        {
	                errx(1,"not enough args");
	        }
	        int fd1,fd2;
	        fd1=open(argv[1], O_RDONLY);
	        fd2=creat(argv[2],S_IRUSR | S_IWUSR);
	        if(fd1 == -1 || fd2== -1)
	        {
	                err(2, "error opening one of the files");
	        }
	        ssize_t rdsz;
	        ssize_t fileSize;
	        if((fileSize=lseek(fd1,0,SEEK_END)) < 0)
	        {
	                err(5,"Error seeking the end of the file");
	        }
	        if(lseek(fd1,0,SEEK_SET) < 0)
	        {
	                err(6,"Error seeking back to the beginning");
	        }
	        uint16_t *buffer=malloc(fileSize);
	        for (int index = 0; index < fileSize; ++index)
	        {
			        if((rdsz=read(fd1, &buffer[index], 1)) < 0)
	                {
	                        err(7,"error reading char by char");
	                }
	        }
	        qsort(buffer,fileSize,sizeof(uint16_t),mycmp);
	        for (int index = 0; index < fileSize; ++index)
	        {
	                if(write(fd2, &buffer[index], 1) != 1)
	                {
	                        err(8,"error writing char by char at %d", index);
	                }
	        }
	        return 0;
	}

### 66. 2019-SE-01

	#include <math.h>
	#include <stdio.h>
	#include <err.h>
	#include <fcntl.h>
	#include <stdlib.h>
	#include <unistd.h>
	#include <stdint.h>
	#include <sys/types.h>
	#include <sys/stat.h>
	#include <string.h>
	struct user_interval
	{
	        uint32_t uid;
	        uint16_t useless1;
	        uint16_t useless2;
	        uint32_t start;
	        uint32_t finish;
	};
	struct interval
	{
	        uint32_t uid;
	        uint32_t length;
	};
	int member(uint32_t usrs[],size_t size, uint32_t elem);
	int member(uint32_t usrs[],size_t size, uint32_t elem)
	{
	        for(size_t i = 0; i < size; i++)
	        {
	                if(usrs[i]==elem)
	                {
	                        return 1;
	                }
	        }
	        return 0;
	}
	size_t findMax(struct interval processes[],size_t size, uint32_t usr);
	size_t findMax(struct interval processes[],size_t size, uint32_t usr)
	{
	        size_t maxInterval=0;
	        for(size_t i =0; i < size; i++)
	        {
	                if(processes[i].uid == usr && processes[i].length > maxInterval)
	                {
	                        maxInterval = processes[i].length;
	                }
	        }
	        return maxInterval;
	}
	int main (const int argc,const char * argv[])
	{
	    // Gather all intervals and calculate mean
	    // for each interval calculate the sum of (x_i - mean)^2 and divide it by their number
	    // for each interval check if it exceeds disperion and print it along with the user name
        if(argc != 2)
        {
                errx(1,"Not enough args");
        }
        int fd1=open(argv[1],O_RDONLY);
        if(fd1 == -1)
        {
                err(2,"error opening %s", argv[1]);
        }
        struct user_interval process;
        struct interval processes[16384];
        ssize_t rdsz;
        size_t size=0;
        double mean=0;
        uint32_t userIds[2048];
        size_t usrSize=0;
        while((rdsz=read(fd1,&process, sizeof(process))) > 0)
        {
                struct interval currProc={process.uid,process.finish-process.start};
                processes[size++]=currProc;
                mean+=currProc.length;
                if(!member(userIds, usrSize, process.uid))
                {
                        userIds[usrSize++]=process.uid;
                }
        }
        mean/=size;
        double dispersion=0;
        for(size_t i = 0; i < size; i++)
        {
                double tmp = (processes[i].length-mean)*(processes[i].length-mean);
                dispersion+=tmp;
        }
        dispersion/=size;
        for(size_t i = 0; i < usrSize; i++)
        {
                size_t maxInterval = findMax(processes, size, userIds[i]);
                if(maxInterval > dispersion)
                {
                        printf("%u %lu", userIds[i], maxInterval);
                }
        }
        return 0;
	}

### 67. 2020-IN-01
	#include <stdio.h>
	#include <err.h>
	#include <fcntl.h>
	#include <stdlib.h>
	#include <unistd.h>
	#include <stdint.h>
	#include <sys/types.h>
	#include <sys/stat.h>
	#include <string.h>
	struct PATCH
	{
	        uint32_t magic;
	        uint8_t headerVersion;
	        uint8_t dataVersion;
	        uint16_t count;
	        uint32_t reserved1;
	        uint32_t reserved2;
	};
	struct PATCH_00
	{
	        uint16_t offset;
	        uint8_t originalByte;
	        uint8_t newByte;
	};
	struct PATCH_01
	{
	        uint32_t offset;
	        uint16_t originalWord;
	        uint16_t newWord;
	};
	int main (const int argc,const char * argv[])
	{
	    if(argc != 4)
	    {
	           errx(1,"insufficient args");
	    }
        int fd1,fdpatch,fd2;
        fd1=open(argv[2], O_RDONLY);
        fdpatch= open(argv[1], O_RDONLY);
        fd2=creat(argv[3], S_IRUSR | S_IWUSR);
        if(fd1 == -1 || fdpatch == -1 || fd2 == -1)
        {
                err(2,"Error opening one of the files");
        }

        ssize_t rdsz;
        struct PATCH currPatch;
        if((rdsz=read(fdpatch,&currPatch,sizeof(currPatch))) < 0)
        {
                err(3,"error reading patch header");
        }

        if(currPatch.dataVersion == 0x00)
        {
                // struct PATCH_00
                // same as 60 but with different structures depending on dataVersion
        }
        else
        {
                // struct PATCH_01
                // same as 60 but with different structures depending on dataVersion
        }

        return 0;
	}


### 68. 2020-SE-01
	#include <stdio.h>
	#include <err.h>
	#include <fcntl.h>
	#include <stdlib.h>
	#include <unistd.h>
	#include <stdint.h>
	#include <sys/types.h>
	#include <sys/stat.h>
	#include <string.h>
	struct package
	{
	        uint16_t post_no;
	        uint16_t post_count;
	        uint16_t pre_no;
	        uint16_t pre_count;
	        uint16_t in_no;
	        uint16_t in_count;
	        uint16_t suf_no;
	        uint16_t suf_count;
	};
	int main (const int argc,const char * argv[])
	{
	        if(argc!=7)
	        {
	                errx(1,"insufficient args");
	        }

        int fdaff,fdpost,fdpre,fdin,fdsuf,fdcru;
        fdaff=open(argv[1],O_RDONLY);

        fdpost=open(argv[2],O_RDONLY);
        fdpre=open(argv[3],O_RDONLY);
        fdin=open(argv[4],O_RDONLY);
        fdsuf=open(argv[5],O_RDONLY);
        fdcru=creat(argv[6],S_IRUSR | S_IWUSR);
        if(fdaff == -1 || fdpost == -1 || fdpre == -1 || fdin == -1 || fdsuf == -1 || fdcru == -1)
        {
                err(2,"Error opening/creating one of the files");
        }

        ssize_t sz;
        uint32_t affCnt=0,postCnt=0,preCnt=0,inCnt=0,sufCnt=0;
        lseek(fdaff,5,SEEK_SET);
        lseek(fdpost,5,SEEK_SET);
        lseek(fdpre, 5, SEEK_SET);
        lseek(fdin,5,SEEK_SET);
        lseek(fdsuf,5,SEEK_SET);

        if((sz=read(fdaff,&affCnt,sizeof(affCnt))) < 0 || (sz=read(fdpost, &postCnt,sizeof(postCnt))) < 0 || (sz=read(fdin,&inCnt,sizeof(inCnt))) < 0 || (sz=read(fdsuf,&sufCnt,sizeof(sufCnt)))< 0)
        {
                err(3,"Error reading one of the counts");
        }

        struct package currPack;
        uint32_t postNum=0;
        uint8_t preNum=0;
        uint64_t sufNum=0;
        uint16_t inNum=0;
        while((sz=read(fdaff,&currPack, sizeof(currPack))) > 0)
        {
                if(currPack.post_no + currPack.post_count > postCnt || currPack.pre_no + currPack.pre_count > preCnt || currPack.in_no + currPack.in_count > inCnt || currPack.suf_no + currPack.suf_count > sufCnt )
                {
                        err(5,"Incosistent file.");
                }
                if(lseek(fdpost,currPack.post_no,SEEK_SET) < 0 || lseek(fdpre,currPack.pre_no, SEEK_SET) < 0 || lseek(fdin,currPack.in_no, SEEK_SET) < 0 || lseek(fdsuf, currPack.suf_no, SEEK_SET) < 0)
                {
                        err(4,"Error seeking one of the _no's");
                }

                for(size_t i = 0; i < currPack.post_count;i++)
                {
                        if((sz=read(fdpost,&postNum,sizeof(postNum)))< 0)
                        {
                                err(6,"Error reading for postNum");
                        }

                        if(write(fdcru,&postNum,sizeof(postNum)) != sizeof(postNum))
                        {
                                err(6,"Error writing postNum");
                        }
                }
                for(size_t i = 0; i < currPack.pre_count;i++)
                {
                        if((sz=read(fdpre,&preNum,sizeof(preNum)))< 0)
                        {
                                err(6,"Error reading for postNum");
                        }

                        if(write(fdcru,&preNum,sizeof(preNum)) != sizeof(preNum))
                        {
                                err(6,"Error writing postNum");
                        }
                }
                for(size_t i = 0; i < currPack.in_count;i++)
                {
                        if((sz=read(fdin,&inNum,sizeof(inNum)))< 0)
                        {
                                err(6,"Error reading for postNum");
                        }

                        if(write(fdcru,&inNum,sizeof(inNum)) != sizeof(inNum))
                        {
                                err(6,"Error writing postNum");
                        }
                }
                for(size_t i = 0; i < currPack.suf_count;i++)
                {
                        if((sz=read(fdsuf,&sufNum,sizeof(sufNum)))< 0)
                        {
                                err(6,"Error reading for postNum");
                        }

                        if(write(fdcru,&sufNum,sizeof(sufNum)) != sizeof(sufNum))
                        {
                                err(6,"Error writing postNum");
                        }
                }
        }

        return 0;
	}

### 69. 2020-SE-02
Idea: Read uint8_t number. To see where this bit is located, divide number by 8 to get in which octet the bit is located. After that to get the position of the bit in the octet -> offset%8; Then seek to the byte that contais our bit. Afterwards shift the number bitwise offset%8 times to the left. Using mask 10000000 we can get that bit and check if it is 128 or 0(128 will equal 1 when we print it later on); If it is 128 then write offset to the resulting file.

	#include <stdio.h>
	#include <err.h>
	#include <fcntl.h>
	#include <stdlib.h>
	#include <unistd.h>
	#include <stdint.h>
	#include <sys/types.h>
	#include <sys/stat.h>
	#include <string.h>
	int main (const int argc,const char * argv[])
	{
	        if(argc !=3)
	        {
	                errx(1,"insufficient args");
	        }
	        uint8_t mask = 128; // 10000000
	        uint8_t num,masked;
	        uint16_t offset;
	        int scl,sdl,res;
	        scl=open(argv[1],O_RDONLY);
	        sdl=open(argv[2],O_RDONLY);
	        res=creat("result", S_IRUSR | S_IWUSR);
	        if(scl==-1 || sdl == -1 || res == -1)
	        {
	                err(2,"Error opening one of the files");
	        }

	        ssize_t rdsz,rdsz2;
        while((rdsz=read(sdl,&offset,sizeof(offset))) > 0)
        {
                uint8_t currByte=offset/8;
                uint8_t inBytePosition = offset%8;
                if(lseek(scl,currByte,SEEK_SET) < 0)
                {
                        err(3,"Error seeking byte");
                }
                if((rdsz2=read(scl,&num,sizeof(num))) < 0)
                {
                        err(4,"Error reading num from scl");
                }
                num<<=inBytePosition;
                masked=num & mask;
                if(masked == 128)
                {
                        if(write(res,&offset,sizeof(offset)) != sizeof(offset))
                        {
                                err(5,"Error writing masked bit to result");
                        }
                }
        }
        return 0;
	}

### 70. 2021-SE-01
Idea: Read uint8_t number from input.bin and for each of these numbers use a bit mask=00000001 to get the last bit of each uint8_t number. If the bit is 1 then to a variable resultNum add 0*2^(deg++) + 1*2^(deg++) where deg begins from 0. If bit is 0 then to resultNum add 1*2^(deg++) + 0*2^(deg++). Repeat this for all of the 8 bits in the number that we read from input.bin. After that just write resultNum to file.


	#include <stdio.h>
	#include <err.h>
	#include <math.h>
	#include <fcntl.h>
	#include <stdlib.h>
	#include <unistd.h>
	#include <stdint.h>
	#include <sys/types.h>
	#include <sys/stat.h>
	#include <string.h>
	uint16_t myPow(uint16_t num,uint16_t deg);
	uint16_t myPow(uint16_t num,uint16_t deg)
	{
	    uint16_t var=num;
	    if(deg==0)
	    {
	            return 1;
	    }
	    for(int i = 1; i < deg; i++)
	    {
	            num*=var;
	    }
	    return num;
	}
	int main (const int argc,const char * argv[])
	{
	    if(argc !=3)
	    {
	            errx(1,"insufficient args");
		}
	    uint8_t mask = 1; // 00000001
	    uint8_t num,masked;
	    int fd1,res;
	    fd1=open(argv[1],O_RDONLY);
	    res=creat(argv[2], S_IRUSR | S_IWUSR);
	    if(fd1==-1 || res == -1)
	    {
	            err(2,"Error opening one of the files");
	    }
        ssize_t rdsz;
        while((rdsz=read(fd1,&num,sizeof(num))) > 0)
        {
                uint16_t resultNum=0;
                uint16_t deg=0,deg16=0;
                uint32_t magic = 0x699A;
                if(write(res,&magic,sizeof(magic)) != sizeof(magic))
                {
                        err(5,"Error writing resultNum to result file");
                }
                while(deg <= 7)
                {
                        masked=num&mask;
                        if(masked == 1)
                        {
                                deg16++;
                                resultNum+=myPow(2,deg16);
                                deg16++;
                                //printf("bit is 1:  %u %u\n",deg16,resultNum);
                        }
                        else
                        {
                                resultNum+=myPow(2,deg16);
                                deg16+=2;
                                //printf("bit is 0:  %u %u\n",deg16, resultNum);
                        }
                        num>>=1;
                        deg++;
                }
                if(write(res,&resultNum,sizeof(resultNum)) != sizeof(resultNum))
                {
                        err(5,"Error writing resultNum to result file");
                }
                //printf("my resultNum: %u\n",resultNum);
        }
        return 0;
	}

### 71. 2021-SE-02
	#include <stdio.h>
	#include <err.h>
	#include <fcntl.h>
	#include <stdlib.h>
	#include <unistd.h>
	#include <stdint.h>
	#include <sys/types.h>
	#include <sys/stat.h>
	#include <string.h>
	uint8_t myPow(uint8_t num,uint16_t deg);
	uint8_t myPow(uint8_t num,uint16_t deg)
	{
	        uint8_t var=num;
	        if(deg==0)
	        {
	                return 1;
	        }
	        for(int i = 1; i < deg; i++)
	        {
	                num*=var;
	        }
	        return num;
	}
	int main (const int argc,const char * argv[])
	{
	        if(argc != 3)
	        {
	                errx(1,"insufficient args");
	        }
	        uint16_t encoded,mask=1;
	        int fd1,res;
	        fd1=open(argv[1], O_RDONLY);
	        res=creat(argv[2],S_IRUSR | S_IWUSR);
	        if(fd1 == -1)
	        {
	                err(2,"Error opening encoded file.");
	        }
        ssize_t rdsz;
        // 10011001 10011010
        while((rdsz=read(fd1,&encoded,sizeof(encoded)))>0)
        {
                uint16_t currBitPair=8,deg=0;
                uint8_t resultNum,left,right;
                while(currBitPair >0)
                {
                        right=encoded & mask;
                        encoded>>=1;
                        left=encoded & mask;
                        encoded>>=1;
                        if(left == 1 && right == 0)
                        {
                                resultNum+=myPow(2,deg);
                                deg++;
                        }
                        else // 0 1
                        {
                                deg++;
                        }
                        currBitPair--;
                }
                if(write(res,&resultNum,sizeof(resultNum)) != sizeof(resultNum))
                {
                        err(3,"Error writing the decoded num");
                }
        }
        return 0;
	}

### 73. 2022-IN-01
	#include <stdio.h>
	#include <err.h>
	#include <fcntl.h>
	#include <stdlib.h>
	#include <unistd.h>
	#include <stdint.h>
	#include <sys/types.h>
	#include <sys/stat.h>
	#include <string.h>
	struct HEADER_STR
	{
	        uint16_t magic;
	        uint16_t fileType;
	        uint32_t count;
	};
	struct LIST_STR
	{
	        uint8_t off_data;
	        uint8_t off_out;
	};
	int myCmp(const void * left, const void * right);
	int myCmp(const void * left, const void * right)
	{
	        const struct LIST_STR * leftP = (const struct LIST_STR *)left;
	        const struct LIST_STR *rightP = (const struct LIST_STR *)right;
	        return leftP->off_out - rightP->off_out;
	}
	int main (const int argc,const char * argv[])
	{
	        uint16_t outFileType=3;
	        uint16_t outMagic=0x5A4D;
	        if(argc != 4)
	        {
	                errx(1,"insufficient args");
	        }
	        int fdlist,fddata,fdout,fdtmp,fdtmp2;
	        fdlist=open(argv[1], O_RDONLY);
	        fddata=open(argv[2], O_RDONLY);
	        fdout=creat(argv[3], S_IRUSR | S_IWUSR);
	        fdtmp=creat("tmp", S_IRUSR | S_IWUSR);
	        fdtmp2=creat("tmp2", S_IRUSR | S_IWUSR);
	        if(fdlist == -1 || fddata == -1 || fdout == -1 || fdtmp == -1 || fdtmp2 == -1)
	        {
	                err(2, "Error opening/creating one of the files");
	        }

        ssize_t rdsz,rdsz1;
        struct HEADER_STR listH,dataH,outH;
        if((rdsz=read(fdlist,&listH,sizeof(listH))) < 0 || (rdsz1=read(fddata,&dataH,sizeof(dataH))) < 0)
        {
                err(3,"Error reading header from data or list.");
        }

        outH.magic = outMagic;
        outH.fileType = outFileType;
        outH.count = listH.count;

        if(write(fdout,&outH,sizeof(outH)) != sizeof(outH))
        {
                err(10,"error writing header of out to out.bin");
        }

        size_t ind=0,ind2=0;
        struct LIST_STR listStr;
        struct LIST_STR * list = malloc(listH.count/2); // todo::
        while((rdsz=read(fdlist,&listStr,sizeof(listStr))) > 0 && ind < listH.count/2)
        {
                list[ind++]=listStr;
        }

        qsort(list, ind, sizeof(listStr),myCmp); // first half is sorted and written
        for(size_t i = 0; i < ind; i++)
        {
                if(write(fdtmp, &list[i], sizeof(listStr)) != sizeof(listStr))
                {
                        err(4, "Error writing list str to tmp file");
                }
        }

        while((rdsz=read(fdlist,&listStr,sizeof(listStr))) > 0)
        {
                list[ind2++]=listStr;
        }
        qsort(list, ind2, sizeof(listStr),myCmp);
        lseek(fdtmp, 0, SEEK_SET);

        size_t currInd=0;
        while((rdsz=read(fdtmp,&listStr,sizeof(listStr))) > 0 && currInd < ind2)
        {
                struct LIST_STR arrList = list[currInd];
                if(listStr.off_out < arrList.off_out)
                {
                        if(write(fdtmp2, &listStr, sizeof(listStr)) != sizeof(listStr))
                        {
                                err(5,"Error writing listStr from file to fdtmp2");
                        }
                }
                else
                {
                        if(write(fdtmp2,&arrList, sizeof(arrList)) != sizeof(arrList))
                        {
                                err(6,"Error writing arrList from array to fdtmp2");
                        }
                        currInd++;
                        lseek(fdtmp,-1,SEEK_CUR);
                }
        }

        while(rdsz > 0 && (rdsz=read(fdtmp,&listStr, sizeof(listStr))) > 0)
        {
                if(write(fdtmp2,&listStr, sizeof(listStr)) != sizeof(listStr))
                {
                        err(6,"Error writing rest of listStr from file to fdtmp2");
                }
        }

        while(currInd < ind2)
        {
                if(write(fdtmp2, &list[currInd],sizeof(list[currInd])) != sizeof(list[currInd]))
                {
                        err(7,"Error writing the rest of list to fdtmp2");
                }
        }

        while((rdsz=read(fdtmp2, &listStr, sizeof(listStr))) > 0)
        {
                lseek(fddata, listStr.off_data, SEEK_SET);
                uint32_t dataNum;
                ssize_t rdsz2;
                if((rdsz2=read(fddata,&dataNum,sizeof(dataNum))) < 0)
                {
                        err(8,"Error reading dataNum from data.bin");
                }
                uint64_t outNum=(uint64_t)dataNum;
                if(write(fdout,&outNum,sizeof(outNum)) != sizeof(outNum))
                {
                        err(9,"ERror writing outNum to out.bin");
                }
        }

        free(list);
        return 0;
	}

### 74. 2022-SE-01
	#include <stdio.h>
	#include <err.h>
	#include <fcntl.h>
	#include <stdlib.h>
	#include <unistd.h>
	#include <stdint.h>
	#include <sys/types.h>
	#include <sys/stat.h>
	#include <string.h>
	struct DataHeader
	{
	        uint32_t magic;
	        uint32_t count;
	};
	struct ComparatorHeader
	{
	        uint32_t magic1;
		    uint16_t magic2;
	        uint16_t reserved;
	        uint64_t count;
	};
	struct ComparatorData
	{
	        uint16_t type;
	        uint16_t reserved1,reserved2,reserved3;
	        uint32_t offset1;
	        uint32_t offset2;
	};
	int main (const int argc,const char * argv[])
	{
	    if(argc!=3)
	    {
	            errx(1,"insufficient args");
	    }

        int fddata,fdcomp;
        fddata=open(argv[1],O_RDONLY);
        fdcomp=open(argv[2],O_RDONLY);
        if(fddata == -1 || fdcomp == -1)
        {
                err(2,"Error opening one of the files");
        }

        struct DataHeader dataH;
        struct ComparatorHeader compH;
        struct ComparatorData compData;
        ssize_t rdsz;

        if((rdsz=read(fddata,&dataH,sizeof(dataH))) <0 || (rdsz=read(fdcomp,&compH,sizeof(compH))) <0)
        {
                err(3,"Error reading dataHeader or compHeader");
        }

        if(dataH.magic != 0x21796F4A || compH.magic1 != 0xAFBC7A37 || compH.magic2 != 0x1C27)
        {
                errx(4,"Incosistent files");
        }

        uint64_t data;
        size_t dataInd=0;
        uint64_t * dataArr=malloc(dataH.count);
        while((rdsz=read(fddata,&data, sizeof(data))) >0)
        {
                dataArr[dataInd++]=data;
        }

        close(fddata);
        fddata=open(argv[1], O_WRONLY | O_TRUNC);
        if(fddata == -1)
        {
                err(5, "Failed opening/truncating data.bin");
        }

        if(write(fddata, &dataH, sizeof(dataH)) != sizeof(dataH))
        {
                err(6, "Error writing header of dataH to data.bin");
        }

        while((rdsz=read(fdcomp,&compData, sizeof(compData))) > 0)
        {
                if(compData.reserved1 != 0 || compData.reserved2 != 0 || compData.reserved3 != 0 || compData.type > 1)
                {
                        errx(7,"Incosistent files");
                }

                uint32_t off1 = compData.offset1-64,off2=compData.offset2-64;
                if(compData.type == 0)
                {
                        if(dataArr[off1] > dataArr[off2])
                        {
                                uint64_t tmp = dataArr[off1];
                                dataArr[off1]= dataArr[off2];
                                dataArr[off2]= tmp;
                        }
                }
                else
                {
                        if(dataArr[off1] < dataArr[off2])
                        {
                                uint64_t tmp = dataArr[off1];
                                dataArr[off1]= dataArr[off2];
                                dataArr[off2]= tmp;
                        }
                }
        }

        for(size_t i =0; i < dataH.count; i++)
        {
                if(write(fddata,&dataArr[i],sizeof(dataArr[i])) != sizeof(dataArr[i]))
                {
                        err(8,"Error writing the correct data to data.bin");
                }
        }
        free(dataArr);
        close(fddata);
        close(fdcomp);
        return 0;
	}

