<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>2.1</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__html"><p><a href="https://drive.google.com/file/d/1W7nO7o6HdBlX7_W8NHI7whcoSU3bO4MU/view?usp=share_link">https://drive.google.com/file/d/1W7nO7o6HdBlX7_W8NHI7whcoSU3bO4MU/view?usp=share_link</a></p>
<h3 id="template">Template</h3>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;err.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdint.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;string.h&gt;
int main (const int argc,const char * argv[]) 
{
}
</code></pre>
<h3 id="se-01-idea---counting-sort-0..255">54. 2016-SE-01 Idea - Counting sort [0…255]</h3>
<pre><code>#include &lt;fcntl.h&gt; 
#include &lt;stdio.h&gt;
#include &lt;err.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdint.h&gt;
int main(int argc, char* argv[])
{
        if (argc != 3)
        {
                errx(1, "Error: not enough args");
        }
        int fd1,fd2;
	    fd1 = open(argv[1], O_RDONLY);
        if (fd1 == -1)
        {
                err(2,"Couldnt open %s for reading",argv[1]);
        }

        ssize_t count_sort[UINT8_MAX+1]={0,};
        ssize_t read_size;
        uint8_t b;
        while((read_size=read(fd1,&amp;b,1)) &gt; 0)
        {
                count_sort[b]++;
        }

        if(read_size == -1)
        {
                err(5,"err");
        }

        fd2 = creat(argv[2],S_IRUSR | S_IWUSR);
        if (fd2 == -1)
        {
                err(3,"Couldnt open %s for reading/writing", argv[2]);
        }

        for(uint8_t i = 0; i &lt; UINT8_MAX; i++)
        {
                for (ssize_t j = 0; j &lt; count_sort[i];j++)
                {
                        if(write(fd2,&amp;i,1) != 1)
                        {
                                err(4, "There was error reading %c", i);
                        }
                }
        }
        return 0;
}
</code></pre>
<h3 id="se-02">55. 2016-SE-02</h3>
<pre><code>#include&lt;stdint.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;err.h&gt;
#include &lt;stdio.h&gt;

struct interval_m
{
        uint32_t begin;
        uint32_t length;
};

int main (const int argc,const char* argv[])
{
        if (argc != 3)
        {
                errx(2,"args not enough");
        }
        int fd1= open(argv[1], O_RDONLY);
        if (fd1 == -1)
        {
                err(1,"err opening fd1");
        }

        int fd2 = open(argv[2], O_RDONLY);
        if (fd2 == -1)
        {
                err(4,"couldnt open file2 for reading");
        }

        int fd3 = creat("result",S_IRUSR | S_IWUSR);

        uint32_t buf;
        ssize_t read_size,read_size2;
        struct interval_m interval;
        while ((read_size=read(fd1, &amp;interval,sizeof(interval)))== sizeof(interval))
        {
                printf("%d %d", interval.begin, interval.length);
                if(lseek(fd2,interval.begin, SEEK_SET) == -1)
                {
                        err(3,"There was error setting pointer in fd2");
                }

                for(size_t i=0;i&lt;interval.length;i++)
                {
                        read_size2=read(fd2,&amp;buf,sizeof(buf));

                        if(read_size2 == -1)
                        {
                                err(5,"Couldnt read from file2");
                        }
                        else if (read_size2 != sizeof(buf))
                        {
                                err(6,"there was difference in the read bytes and the expected read bytes");
                        }

                        if(write(fd3, &amp;buf, sizeof(buf)) != sizeof(buf))
                        {
                                err(7, "couldnt write to result file");
                        }
                }
        }

        if(read_size == -1) { err (8, "reading from file1 has failed");}
        else if (read_size &gt; 0) { err(9,"file1 reading error");}

        return 0;
</code></pre>
<p>}</p>
<h3 id="se-03-idea---get--the-first-50-000-000-binary-numbers---sort-them---write-them-to-a-tmp_1-file.-then-get-the-other-50-000-000---sort-them---do-merge-sort-on-the-tmp_1-file-and-the-currently-sorted-array">56. 2016-SE-03 Idea - Get  the first 50 000 000 binary numbers -&gt; sort them -&gt; write them to a tmp_1 file. Then get the other 50 000 000 -&gt; sort them -&gt; do merge sort on the tmp_1 file and the currently sorted array</h3>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;err.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdint.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;

static int mycmp(const void *left, const void *right)
{

        if(*(const uint32_t *)left == *(const uint32_t *)right)
        {
                return 0;
        }
        else if(*(const uint32_t *)left &gt; *(const uint32_t *)right)
        {
                return 1;
        }
        else
        {
                return -1;
        }

}

int main(const int argc, const char* argv[]){
        if(argc != 2) { errx(1,"not enough args"); }
        int fd1,fd2,fd3,fd4;
        fd1=open(argv[1],O_RDONLY);
        fd2=open("sorted",S_IRUSR | S_IWUSR);
        fd3=creat("tmp", S_IRUSR | S_IWUSR);
        fd4=creat("tmp2",S_IRUSR | S_IWUSR);
        if (fd1 == -1 || fd2 == -1 || fd3 == -1 || fd4 == -1)
        {
                err(2,"Error opening fd1 or fd2 for read/write");
        }

        uint32_t buff[50000000];
        ssize_t readsize,readsize2;
        readsize=read(fd1,&amp;buff,sizeof(buff));
        if(readsize==-1 || readsize != sizeof(buff)){ err(3,"error reading from fd1 on first half");}
        qsort(buff,sizeof(buff),sizeof(uint32_t),mycmp);
        if(write(fd3, &amp;buff, sizeof(buff)) != sizeof(buff))
        {
                err(4,"error writing first half to fd3");
        }

        if((readsize2= read(fd1,&amp;buff,sizeof(buff))) == -1)
        {
                err(5,"err reading second half from fd1");
        }

        qsort(buff, sizeof(buff),sizeof(uint32_t),mycmp);
        if(write(fd4,&amp;buff,sizeof(buff))!= sizeof(buff))
        {
                err(6,"error writing to fd4 second half");
        }

        lseek(fd3,0,SEEK_SET);
        lseek(fd4,0,SEEK_SET);

        uint32_t left,right;
        while((readsize=read(fd3,&amp;left,sizeof(left))&gt;0 &amp;&amp; (readsize2=read(fd4,&amp;right,sizeof(right)))&gt;0 ))
        {
                if(left &lt; right)
                {
                        if(write(fd2,&amp;left, sizeof(left))!= sizeof(left))
                        {
                                err(7,"error writing to the sorted file");
                        }
                        if((readsize=read(fd3,&amp;left,sizeof(left))) == -1)
                        {
                                err(8,"error reading from fd3 (left)");
                        }
                        if(readsize != sizeof(left))
                        {
                                err(9, "bytes read differ from expected bytes to read");
                        }

                        while(left &lt; right)
                        {
                                if(write(fd2,&amp;left, sizeof(left))!= sizeof(left))
                                {
                                        err(7,"error writing to the sorted file");
                                }

                                if((readsize=read(fd3,&amp;left,sizeof(left)))== -1)
                                {
                                        err(8, "error reading from fd3 (left)");
                                }
                                if(readsize != sizeof(left))
                                {
                                        err(9,"bytes read differ from expected bytes to read");
                                }
                        }
                }
                else
                {
                        if(write(fd2,&amp;right,sizeof(right)) != sizeof(right))
                        {
                                err(7,"error writing to sorted file");
                        }

                        if((readsize2=read(fd4,&amp;right,sizeof(right))==-1))
                        {
                                err(10,"error reading from fd4 (right)");
                        }
                        if(readsize != sizeof(right))
                        {
                                err(11,"bytes read differ from expected bytes to read for fd4");
                        }

                        while(right &lt; left)
                        {
                                if(write(fd2,&amp;right, sizeof(right))!= sizeof(right))
                                {
                                        err(7,"error writing to the sorted file");
                                }

                                if((readsize2=read(fd4,&amp;right,sizeof(right)))== -1)
                                {
                                        err(10, "error reading from fd4 (right)");
                                }
                                if(readsize2 != sizeof(right))
                                {
                                        err(11,"bytes read differ from expected bytes to read for fd4");
                                }
                        }
                }
        }

        if(readsize &gt; 0)
        {
                while((readsize=read(fd3,&amp;left,sizeof(left)))&gt;0)
                {
                        if(write(fd2,&amp;left, sizeof(left))!= sizeof(left))
                        {
                                err(7,"error writing to the sorted file");
                        }
                }
        }

        if(readsize2 &gt; 0)
        {
                while((readsize2=read(fd4,&amp;right,sizeof(right)))&gt;0)
                {
                        if(write(fd2,&amp;right, sizeof(right))!= sizeof(right))
                        {
                                err(7,"error writing to the sorted file");
                        }
                }
        }

        close(fd1);
        close(fd2);
        close(fd3);
        close(fd4);
        return 0;
}
</code></pre>
<h3 id="in-01">57. 2017-IN-01</h3>
<p>Идея: четем от .idx файла който са ни дали, като четем sizeof(DAT) на брой байтове. За всяка такава структура бъркаме във първият файл на offset DAT.offset и в динамично заделен масив (buffer) с големина DAT.length четем толкова на брой байтове. Проверяваме дали buffer[0] е главна и ако е главна записваме съответната дума във файл с име &lt;трети подаден аргумент&gt;, а DAT структурата я записваме в файл с име &lt;четвърти подаден аргумент&gt;.</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;err.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdint.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;

struct DAT
{
        uint16_t offset;
        uint8_t  length;
        uint8_t  saved;
};

int main (const int argc,const char * argv[])
{
    if(argc != 5)
    {
            errx(1,"not enough args");
    }
    int fd1,fd2,fd3,fd4;
    fd1=open(argv[1], O_RDONLY);
    fd2=open(argv[2], O_RDONLY);
    fd3=creat(argv[3], S_IRUSR | S_IWUSR);
    fd4=creat(argv[4], S_IRUSR | S_IWUSR);

    if(fd1 == -1 || fd2 == -1 || fd3==-1 || fd4==-1)
    {
            err(2,"error opening/creating one of the files");
    }

    int readsize,readsize2;
    struct DAT dat_str;
    struct DAT currDat;
    currDat.offset = 0;
    currDat.length = 0;
    currDat.saved  = 0;

    while((readsize=read(fd2,&amp;dat_str, sizeof(dat_str))) &gt; 0)
    {
            lseek(fd1,dat_str.offset,SEEK_SET);

            uint8_t c;
            uint8_t currLen=dat_str.length;
            if((readsize2 = read(fd1,&amp;c, sizeof(uint8_t)))&lt; 0)
            {
                    err(3,"error reading first char from word");
            }
            currLen--;


            if(c &gt;= 0x41 &amp;&amp; c &lt;= 0x5A)
            {
                    if(write(fd3,&amp;c,sizeof(uint8_t)) != sizeof(uint8_t))
                    {
                            err(4,"error writing the upper case letter");
                    }

                    while((readsize2=read(fd1,&amp;c,sizeof(uint8_t))) &gt; 0 &amp;&amp; currLen &gt; 0)
                    {
                            if(write(fd3, &amp;c, sizeof(uint8_t)) != sizeof(uint8_t))
                            {
                                    err(5,"Error writing to fd3 of char %u", c);
                            }

                            currLen--;
                    }

                    currDat.length = dat_str.length;
                    currDat.saved  = dat_str.saved;
                    if(write(fd4, &amp;currDat, sizeof(currDat)) != sizeof(currDat))
                    {
                            err(6, "error writing to fd4 of Dat structure: %d %d %d", dat_str.offset, dat_str.length,dat_str.saved);
                    }

                    currDat.offset+=dat_str.length;
            }
    }

    return 0;
}
</code></pre>
<h3 id="se-01">58. 2017-SE-01</h3>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;err.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdint.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;

struct PATCH_STR
{
    uint16_t offset;
    uint8_t originalByte;
    uint8_t newByte;
};

int main (const int argc,const char * argv[])
{
    if(argc != 4)
    {
         errx(1,"not enough args");
    }

    int fd1,fd2,fdpatch;
    fd1=open(argv[1], O_RDONLY);
    fd2=open(argv[2], O_RDONLY);
    fdpatch=creat(argv[3], S_IRUSR | S_IWUSR);
    if (fd1 == -1 || fd2 == -1 || fdpatch == -1)
    {
            err(2,"Error opening/creating one of the files");
    }

    uint8_t left,right;
    int readsize,readsize2,counter=0;
    while((readsize=read(fd1,&amp;left,sizeof(left)) &gt;0 &amp;&amp; (readsize2=read(fd2,&amp;right,sizeof(right)))&gt; 0))
    {
            if(left != right)
            {
                    struct PATCH_STR strToWrite;
                    strToWrite.offset = counter;
                    strToWrite.originalByte=left;
                    strToWrite.newByte=right;
                    if(write(fdpatch, &amp;strToWrite, sizeof(strToWrite)) != sizeof(strToWrite))
                    {
                            err(3,"error writing the struct to %s", argv[3]);
                    }
            }

            counter++;
    }

    return 0;
}
</code></pre>
<h3 id="se-02-1">59. 2017-SE-02</h3>
<pre><code>#include &lt;stdlib.h&gt;
#include &lt;err.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdint.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

enum exit_code
{
        ARG_ERR = 1,

        READ_ERR,
        WRITE_ERR,
        OPEN_ERR,
        OTHER_ERR,
        CLOSE_ERR
};

void rdwr(const int fdrd, const int fdwr, uint8_t enumerate);

void rdwr(const int fdrd, const int fdwr, uint8_t enumerate)
{
        int n = 1;

    char buf;

    char nbuf[256];

    ssize_t rdsz;

    // ???
    if (enumerate == 1)
    {
            sprintf(nbuf, "%d ", n);
            fputs(nbuf, stdout);
            fflush(stdout);
    }

    while ((rdsz = read(fdrd, &amp;buf, 1)) &gt; 0)
    {
            if (write(fdwr, &amp;buf, 1) != 1)
            {
                    err(WRITE_ERR, "writing err");
            }

            // ???
            if (buf == '\n' &amp;&amp; enumerate == 1)
            {
                    n++;
                    sprintf(nbuf, "%d ", n);
                    setbuf(stdout, nbuf);
                    fputs(nbuf, stdout);
                    fflush(stdout);
            }
    }

    if (rdsz == -1)
    {
            err(READ_ERR, "reading err");
    }
}

int main(const int argc, const char* argv[])
{
        uint8_t enumerate = 0;

    if (argc == 1)
    {
            rdwr(0, 1, enumerate);
            exit(0);
    }

    if (strcmp(argv[1], "-n") == 0)
    {
            enumerate = 1;
    }

    if (argc == 2 &amp;&amp; enumerate == 1)
    {
            rdwr(0, 1, enumerate);
            exit(0);
    }

    int fd;

    int i = (enumerate == 1) ? 2 : 1;

    while (i &lt; argc)
    {
            if (strcmp(argv[i], "-") == 0)
            {
                    fd = 0;
            }
            else if ((fd = open(argv[i], O_RDONLY)) == -1)
            {
                    err(OPEN_ERR, "open err");
            }

            rdwr(fd, 1, enumerate);

            if (fd != 0 &amp;&amp; close(fd) == -1)
            {
                    err(CLOSE_ERR, "close err");
            }

            i++;
    }

    exit(0);
}
</code></pre>
<h3 id="se-03">60. 2017-SE-03</h3>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;err.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdint.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;

struct PATCH_STR
{
    uint16_t offset;
    uint8_t originalByte;
    uint8_t newByte;
};

int main (const int argc,const char * argv[])
{
    if(argc != 4)
    {
         errx(1,"not enough args");
    }

    int fd1,fd2,fdpatch;
    fd1=open(argv[2], O_RDONLY);
    fd2=creat(argv[3], S_IRUSR | S_IWUSR);
    fdpatch=open(argv[1], O_RDONLY);
    if (fd1 == -1 || fd2 == -1 || fdpatch == -1)
    {
            err(2,"Error opening/creating one of the files");
    }

    uint8_t f1Byte;
    int readsize,readsize2;
    uint16_t counter=0;
    struct PATCH_STR patchBin;
    while((readsize=read(fdpatch, &amp;patchBin, sizeof(patchBin))) != 0)
    {
            while((readsize2=read(fd1,&amp;f1Byte,sizeof(f1Byte))) != 0)
            {
                    if(counter == patchBin.offset)
                    {
                            if(write(fd2,&amp;patchBin.newByte, sizeof(patchBin.newByte)) != sizeof(patchBin.newByte))
                            {
                                    err(3,"Error writing new byte to f2.bin");
                            }
                            counter++;
                            break;
                    }
                    else
                    {
                            if(write(fd2,&amp;f1Byte,sizeof(f1Byte)) != sizeof(f1Byte))
                            {
                                    err(4,"Error writing old byte to f2.bin");
                            }
                            counter++;
                    }
            }
    }

    if(readsize &lt; 0 || readsize2 &lt; 0)
    {
            err(5,"error with readsize or readsize2");
    }

    if(readsize2 &gt; 0)
    {
            while((readsize2 = read(fd1,&amp;f1Byte,sizeof(f1Byte))) == sizeof(f1Byte))
            {
                    if(write(fd2,&amp;f1Byte,sizeof(f1Byte)) != sizeof(f1Byte))
                    {
                            err(4,"error writing old byte to f2.bin");
                    }
            }
    }

    return 0;
}
</code></pre>
<h3 id="same-as-59-but-without--n">61 : same as 59 but without “-n”</h3>
<h3 id="se-01-1">62. 2018-SE-01</h3>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;err.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdint.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;string.h&gt;

enum OPTIONS
{
        NO_OP=0,
        S_OP=1,
        D_OP=2,
};

int isInArr(const char* word, uint8_t ch);

int isInArr(const char* word, uint8_t ch)
{
        int wordLen = strlen(word);
        for(int i = 0; i &lt; wordLen; i++)
        {
                if(word[i] == ch)
                {
                        return 1;
                }
        }

    return 0;
}

int main (const int argc,const char * argv[])
{
    enum OPTIONS opt = NO_OP;
    if(argc &lt; 2)
    {
            errx(1,"not enough args");
    }

    if(!strcmp(argv[1], "-d") &amp;&amp; argc == 3)
    {
            opt = D_OP;
    }
    else if(!strcmp(argv[1], "-s") &amp;&amp; argc == 3)
    {
            opt = S_OP;
    }
    else if(strcmp(argv[1],"-s") != 0 &amp;&amp; strcmp(argv[1], "-d") != 0 &amp;&amp; argc == 3)
    {
            opt = NO_OP;
    }
    else
    {
            err(2,"Arguments mismatch");
    }

    if(opt==NO_OP)
    {
            if(strlen(argv[1]) != strlen(argv[2]))
            {
                    errx(3,"Lengths of arrays mismatch");
            }

            int rdsz;
            uint8_t b;
            while((rdsz=read(0,&amp;b,sizeof(b))) &gt; 0)
            {
                    size_t arr1Size = strlen(argv[1]);
                    uint8_t flag=0;
                    for(ssize_t i = arr1Size; i &gt;= 0; i--)
                    {
                            if(argv[1][i] == b)
                            {
                                    if(write(1, &amp;argv[2][i], sizeof(uint8_t)) != sizeof(uint8_t))
                                    {
                                            err(4,"Error writing to stdout of char %u", argv[2][i]);
                                    }
                                    flag = 1;
                                    break;
                            }
                    }

                    if(!flag)
                    {
                            if(write(1,&amp;b,sizeof(b)) != sizeof(b))
                            {
                                    err(5,"Error writing to stdout of same char %u", b);
                            }
                    }
            }

            if(rdsz &lt; 0)
            {
                    err(4,"Error reading with NO_OPT");
            }
    }
    else if(opt == S_OP)
    {
            uint8_t prev,curr;
            int rdsz,rdsz2;
            if((rdsz=read(0,&amp;prev,sizeof(prev))) &lt; 0)
            {
                    err(6,"Error reading prev the first time");
            }

            if(write(1,&amp;prev,sizeof(prev)) != sizeof(prev))
            {
                    err(7,"error writing the first prev");
            }

            while((rdsz2 = read(0,&amp;curr,sizeof(curr))) &gt; 0)
            {
                    if(curr == prev &amp;&amp; isInArr(argv[2],curr))
                    {
                            continue;
                    }
                    else
                    {
                            prev = curr;
                            if(write(1,&amp;curr,sizeof(curr)) != sizeof(curr))
                            {
                                    err(8,"error writing inner curr to the stdout");
                            }
                    }
            }
    }
    else if(opt == D_OP)
    {
            uint8_t curr;
            int rdsz;
            while((rdsz=read(0,&amp;curr,sizeof(curr))) &gt; 0)
            {
                    if(isInArr(argv[2],curr))
                    {
                            continue;
                    }

                    if(write(1,&amp;curr,sizeof(curr)) != sizeof(curr))
                    {
                            err(9,"Error writing curr to stdout in -d mode");
                    }
            }
    }
    else
    {
            errx(10,"Unrecocgnized command!");
    }

    return 0;
}
</code></pre>
<h3 id="se-02-2">64. 2018-SE-02</h3>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;err.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdint.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;string.h&gt;
enum OPTIONS
{
        NO_OP=0,
        C_OP_range=1,
        C_OP_only_one=2,
        D_OP_range=3,
        D_OP_only_one=4,
};
int main (const int argc,const char * argv[])
{
        enum OPTIONS opt = NO_OP;
        if(argc &lt; 3)
        {
                errx(1,"Not enough args for cut");
        }
        // -c
        else if(argc == 3 &amp;&amp; !strcmp(argv[1],"-c"))
        {
                // -c 5
                if(strlen(argv[2])== 1)
                {
                        if(argv[2][0] &lt; 0x30 || argv[2][0] &gt; 0x39)
                        {
                                errx(4,"argument given to -c isnt a number");
                        }
                        opt = C_OP_only_one;
                }
                // -c 3-5
                else if(strlen(argv[2]) == 3)
                {
                        if(argv[2][0] &gt; 0x30 &amp;&amp; argv[2][0] &lt; 0x39 &amp;&amp; argv[2][1] == 0x2D &amp;&amp; argv[2][2] &gt; 0x30 &amp;&amp; argv[2][2] &lt; 0x39)
                        {
                                opt = C_OP_range;
                        }
                        else
                        {
                                errx(2,"Check if your -c arg is appropriate. (e.g 3-5)");
                        }
                }
                else
                {
                        errx(3,"Check your -c arg input (number of args)");
                }
        }
        // -d
        else if(argc == 5 &amp;&amp; !strcmp(argv[1],"-d"))
        {
                if(strcmp(argv[3],"-f"))
                {
                        errx(4,"Incorrect cut args. (-f)");
                }

            // -d ".." -f 1
            if(strlen(argv[4])== 1)
            {
                    opt = D_OP_only_one;
            }
            // -d ".." -f 3-5
            else if(strlen(argv[4]) == 3)
            {
                    if(argv[4][0] &gt; 0x30 &amp;&amp; argv[4][0] &lt; 0x39 &amp;&amp; argv[4][1] == 0x2D &amp;&amp; argv[4][2] &gt; 0x30 &amp;&amp; argv[4][2] &lt; 0x39)
                    {
                            if(argv[4][0] == argv[4][2])
                            {
                                    opt=D_OP_only_one;
                            }
                            else
                            {
                                    opt = D_OP_range;
                            }
                    }
                    else
                    {
                            errx(2,"Check if your field arg is appropriate. (e.g 3-5)");
                    }
            }
            else
            {
                    errx(3,"Check your field input (number of args)");
            }
	        }
	        uint8_t c;
	        int currLen,rdsz,left,right;
	        int currDel=1;
	        switch(opt)
	        {
            case C_OP_only_one:
                    //while((rdsz=read(0,&amp;c,sizeof(c))) &gt; 0)
                    //{
                    currLen=atoi(argv[2]);
                    while((rdsz=read(0,&amp;c,sizeof(c))) &gt; 0)
                    {
                            if(currLen == 1)
                            {
                                    if(write(1,&amp;c,sizeof(c)) != sizeof(c))
                                    {
                                            err(5,"error writing only 1 byte in C_OP_only_one (%u)", c);
                                    }
                                    break;
                            }
                            currLen--;
                    }
                    break;
            case C_OP_range:
                    left=atoi(&amp;argv[2][0]);
                    right=atoi(&amp;argv[2][2]);
                    currLen=1;
                    while((rdsz=read(0,&amp;c,sizeof(c))) &gt; 0)
                    {
                            if(currLen &gt;= left &amp;&amp; currLen &lt;= right)
                            {
                                    if(write(1,&amp;c,sizeof(c)) != sizeof(c))
                                    {
                                            err(6,"error writing char %u of C_OP_range", c);
                                    }
                            }
                            currLen++;
                    }
                    break;
            case D_OP_only_one:
                    currLen=atoi(&amp;argv[4][0]);
                    while((rdsz=read(0,&amp;c,sizeof(c))) &gt; 0 &amp;&amp; currDel &lt;= currLen)
                    {
                            if(c == argv[2][0])
                            {
                                    currDel++;
                                    continue;
                            }
                            if(currDel == currLen)
                            {
                                    if(write(1,&amp;c,sizeof(c)) != sizeof(c))
                                    {
                                            err(7,"ERror writing single char to stdout in C_OP_only_one");
                                    }
                            }
                    }
                    break;
            case D_OP_range:
                    left=atoi(&amp;argv[4][0]);
                    right=atoi(&amp;argv[4][2]);
                    currLen=1;
                    while((rdsz=read(0,&amp;c,sizeof(c))) &gt; 0)
                    {
                            if(c==argv[2][0])
                            {
                                    currDel++;
                                    if(currDel == left)
                                    {
                                            continue;
                                    }
                            }
                            if(currDel &gt;= left &amp;&amp; currDel &lt;=right)
                            {
                                    if(write(1,&amp;c,sizeof(c)) != sizeof(c))
                                    {
                                            err(8,"Error writing char for D_OP_range");
                                    }
                            }
                    }
                    break;
            default:
                    errx(10,"No options");
    }
    printf("\n");
    return 0;
}
</code></pre>
<h3 id="se-04">65. 2018-SE-04</h3>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;err.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdint.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;string.h&gt;
int mycmp(const void *left,const void* right);
int mycmp(const void *left, const void* right)
{
        return (*(const uint16_t *)left - *(const uint16_t *)right);
}
int main (const int argc,const char * argv[])
{
        if(argc != 3)
        {
                errx(1,"not enough args");
        }
        int fd1,fd2;
        fd1=open(argv[1], O_RDONLY);
        fd2=creat(argv[2],S_IRUSR | S_IWUSR);
        if(fd1 == -1 || fd2== -1)
        {
                err(2, "error opening one of the files");
        }
        ssize_t rdsz;
        ssize_t fileSize;
        if((fileSize=lseek(fd1,0,SEEK_END)) &lt; 0)
        {
                err(5,"Error seeking the end of the file");
        }
        if(lseek(fd1,0,SEEK_SET) &lt; 0)
        {
                err(6,"Error seeking back to the beginning");
        }
        uint16_t *buffer=malloc(fileSize);
        for (int index = 0; index &lt; fileSize; ++index)
        {
		        if((rdsz=read(fd1, &amp;buffer[index], 1)) &lt; 0)
                {
                        err(7,"error reading char by char");
                }
        }
        qsort(buffer,fileSize,sizeof(uint16_t),mycmp);
        for (int index = 0; index &lt; fileSize; ++index)
        {
                if(write(fd2, &amp;buffer[index], 1) != 1)
                {
                        err(8,"error writing char by char at %d", index);
                }
        }
        return 0;
}
</code></pre>
<h3 id="se-01-2">66. 2019-SE-01</h3>
<pre><code>#include &lt;math.h&gt;
#include &lt;stdio.h&gt;
#include &lt;err.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdint.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;string.h&gt;
struct user_interval
{
        uint32_t uid;
        uint16_t useless1;
        uint16_t useless2;
        uint32_t start;
        uint32_t finish;
};
struct interval
{
        uint32_t uid;
        uint32_t length;
};
int member(uint32_t usrs[],size_t size, uint32_t elem);
int member(uint32_t usrs[],size_t size, uint32_t elem)
{
        for(size_t i = 0; i &lt; size; i++)
        {
                if(usrs[i]==elem)
                {
                        return 1;
                }
        }
        return 0;
}
size_t findMax(struct interval processes[],size_t size, uint32_t usr);
size_t findMax(struct interval processes[],size_t size, uint32_t usr)
{
        size_t maxInterval=0;
        for(size_t i =0; i &lt; size; i++)
        {
                if(processes[i].uid == usr &amp;&amp; processes[i].length &gt; maxInterval)
                {
                        maxInterval = processes[i].length;
                }
        }
        return maxInterval;
}
int main (const int argc,const char * argv[])
{
    // Gather all intervals and calculate mean
    // for each interval calculate the sum of (x_i - mean)^2 and divide it by their number
    // for each interval check if it exceeds disperion and print it along with the user name
    if(argc != 2)
    {
            errx(1,"Not enough args");
    }
    int fd1=open(argv[1],O_RDONLY);
    if(fd1 == -1)
    {
            err(2,"error opening %s", argv[1]);
    }
    struct user_interval process;
    struct interval processes[16384];
    ssize_t rdsz;
    size_t size=0;
    double mean=0;
    uint32_t userIds[2048];
    size_t usrSize=0;
    while((rdsz=read(fd1,&amp;process, sizeof(process))) &gt; 0)
    {
            struct interval currProc={process.uid,process.finish-process.start};
            processes[size++]=currProc;
            mean+=currProc.length;
            if(!member(userIds, usrSize, process.uid))
            {
                    userIds[usrSize++]=process.uid;
            }
    }
    mean/=size;
    double dispersion=0;
    for(size_t i = 0; i &lt; size; i++)
    {
            double tmp = (processes[i].length-mean)*(processes[i].length-mean);
            dispersion+=tmp;
    }
    dispersion/=size;
    for(size_t i = 0; i &lt; usrSize; i++)
    {
            size_t maxInterval = findMax(processes, size, userIds[i]);
            if(maxInterval &gt; dispersion)
            {
                    printf("%u %lu", userIds[i], maxInterval);
            }
    }
    return 0;
}
</code></pre>
<h3 id="in-01-1">67. 2020-IN-01</h3>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;err.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdint.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;string.h&gt;
struct PATCH
{
        uint32_t magic;
        uint8_t headerVersion;
        uint8_t dataVersion;
        uint16_t count;
        uint32_t reserved1;
        uint32_t reserved2;
};
struct PATCH_00
{
        uint16_t offset;
        uint8_t originalByte;
        uint8_t newByte;
};
struct PATCH_01
{
        uint32_t offset;
        uint16_t originalWord;
        uint16_t newWord;
};
int main (const int argc,const char * argv[])
{
    if(argc != 4)
    {
           errx(1,"insufficient args");
    }
    int fd1,fdpatch,fd2;
    fd1=open(argv[2], O_RDONLY);
    fdpatch= open(argv[1], O_RDONLY);
    fd2=creat(argv[3], S_IRUSR | S_IWUSR);
    if(fd1 == -1 || fdpatch == -1 || fd2 == -1)
    {
            err(2,"Error opening one of the files");
    }

    ssize_t rdsz;
    struct PATCH currPatch;
    if((rdsz=read(fdpatch,&amp;currPatch,sizeof(currPatch))) &lt; 0)
    {
            err(3,"error reading patch header");
    }

    if(currPatch.dataVersion == 0x00)
    {
            // struct PATCH_00
            // same as 60 but with different structures depending on dataVersion
    }
    else
    {
            // struct PATCH_01
            // same as 60 but with different structures depending on dataVersion
    }

    return 0;
}
</code></pre>
<h3 id="se-01-3">68. 2020-SE-01</h3>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;err.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdint.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;string.h&gt;
struct package
{
        uint16_t post_no;
        uint16_t post_count;
        uint16_t pre_no;
        uint16_t pre_count;
        uint16_t in_no;
        uint16_t in_count;
        uint16_t suf_no;
        uint16_t suf_count;
};
int main (const int argc,const char * argv[])
{
        if(argc!=7)
        {
                errx(1,"insufficient args");
        }

    int fdaff,fdpost,fdpre,fdin,fdsuf,fdcru;
    fdaff=open(argv[1],O_RDONLY);

    fdpost=open(argv[2],O_RDONLY);
    fdpre=open(argv[3],O_RDONLY);
    fdin=open(argv[4],O_RDONLY);
    fdsuf=open(argv[5],O_RDONLY);
    fdcru=creat(argv[6],S_IRUSR | S_IWUSR);
    if(fdaff == -1 || fdpost == -1 || fdpre == -1 || fdin == -1 || fdsuf == -1 || fdcru == -1)
    {
            err(2,"Error opening/creating one of the files");
    }

    ssize_t sz;
    uint32_t affCnt=0,postCnt=0,preCnt=0,inCnt=0,sufCnt=0;
    lseek(fdaff,5,SEEK_SET);
    lseek(fdpost,5,SEEK_SET);
    lseek(fdpre, 5, SEEK_SET);
    lseek(fdin,5,SEEK_SET);
    lseek(fdsuf,5,SEEK_SET);

    if((sz=read(fdaff,&amp;affCnt,sizeof(affCnt))) &lt; 0 || (sz=read(fdpost, &amp;postCnt,sizeof(postCnt))) &lt; 0 || (sz=read(fdin,&amp;inCnt,sizeof(inCnt))) &lt; 0 || (sz=read(fdsuf,&amp;sufCnt,sizeof(sufCnt)))&lt; 0)
    {
            err(3,"Error reading one of the counts");
    }

    struct package currPack;
    uint32_t postNum=0;
    uint8_t preNum=0;
    uint64_t sufNum=0;
    uint16_t inNum=0;
    while((sz=read(fdaff,&amp;currPack, sizeof(currPack))) &gt; 0)
    {
            if(currPack.post_no + currPack.post_count &gt; postCnt || currPack.pre_no + currPack.pre_count &gt; preCnt || currPack.in_no + currPack.in_count &gt; inCnt || currPack.suf_no + currPack.suf_count &gt; sufCnt )
            {
                    err(5,"Incosistent file.");
            }
            if(lseek(fdpost,currPack.post_no,SEEK_SET) &lt; 0 || lseek(fdpre,currPack.pre_no, SEEK_SET) &lt; 0 || lseek(fdin,currPack.in_no, SEEK_SET) &lt; 0 || lseek(fdsuf, currPack.suf_no, SEEK_SET) &lt; 0)
            {
                    err(4,"Error seeking one of the _no's");
            }

            for(size_t i = 0; i &lt; currPack.post_count;i++)
            {
                    if((sz=read(fdpost,&amp;postNum,sizeof(postNum)))&lt; 0)
                    {
                            err(6,"Error reading for postNum");
                    }

                    if(write(fdcru,&amp;postNum,sizeof(postNum)) != sizeof(postNum))
                    {
                            err(6,"Error writing postNum");
                    }
            }
            for(size_t i = 0; i &lt; currPack.pre_count;i++)
            {
                    if((sz=read(fdpre,&amp;preNum,sizeof(preNum)))&lt; 0)
                    {
                            err(6,"Error reading for postNum");
                    }

                    if(write(fdcru,&amp;preNum,sizeof(preNum)) != sizeof(preNum))
                    {
                            err(6,"Error writing postNum");
                    }
            }
            for(size_t i = 0; i &lt; currPack.in_count;i++)
            {
                    if((sz=read(fdin,&amp;inNum,sizeof(inNum)))&lt; 0)
                    {
                            err(6,"Error reading for postNum");
                    }

                    if(write(fdcru,&amp;inNum,sizeof(inNum)) != sizeof(inNum))
                    {
                            err(6,"Error writing postNum");
                    }
            }
            for(size_t i = 0; i &lt; currPack.suf_count;i++)
            {
                    if((sz=read(fdsuf,&amp;sufNum,sizeof(sufNum)))&lt; 0)
                    {
                            err(6,"Error reading for postNum");
                    }

                    if(write(fdcru,&amp;sufNum,sizeof(sufNum)) != sizeof(sufNum))
                    {
                            err(6,"Error writing postNum");
                    }
            }
    }

    return 0;
}
</code></pre>
<h3 id="se-02-3">69. 2020-SE-02</h3>
<p>Idea: Read uint8_t number. To see where this bit is located, divide number by 8 to get in which octet the bit is located. After that to get the position of the bit in the octet -&gt; offset%8; Then seek to the byte that contais our bit. Afterwards shift the number bitwise offset%8 times to the left. Using mask 10000000 we can get that bit and check if it is 128 or 0(128 will equal 1 when we print it later on); If it is 128 then write offset to the resulting file.</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;err.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdint.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;string.h&gt;
int main (const int argc,const char * argv[])
{
        if(argc !=3)
        {
                errx(1,"insufficient args");
        }
        uint8_t mask = 128; // 10000000
        uint8_t num,masked;
        uint16_t offset;
        int scl,sdl,res;
        scl=open(argv[1],O_RDONLY);
        sdl=open(argv[2],O_RDONLY);
        res=creat("result", S_IRUSR | S_IWUSR);
        if(scl==-1 || sdl == -1 || res == -1)
        {
                err(2,"Error opening one of the files");
        }

        ssize_t rdsz,rdsz2;
    while((rdsz=read(sdl,&amp;offset,sizeof(offset))) &gt; 0)
    {
            uint8_t currByte=offset/8;
            uint8_t inBytePosition = offset%8;
            if(lseek(scl,currByte,SEEK_SET) &lt; 0)
            {
                    err(3,"Error seeking byte");
            }
            if((rdsz2=read(scl,&amp;num,sizeof(num))) &lt; 0)
            {
                    err(4,"Error reading num from scl");
            }
            num&lt;&lt;=inBytePosition;
            masked=num &amp; mask;
            if(masked == 128)
            {
                    if(write(res,&amp;offset,sizeof(offset)) != sizeof(offset))
                    {
                            err(5,"Error writing masked bit to result");
                    }
            }
    }
    return 0;
}
</code></pre>
<h3 id="se-01-4">70. 2021-SE-01</h3>
<p>Idea: Read uint8_t number from input.bin and for each of these numbers use a bit mask=00000001 to get the last bit of each uint8_t number. If the bit is 1 then to a variable resultNum add 0<em>2^(deg++) + 1</em>2^(deg++) where deg begins from 0. If bit is 0 then to resultNum add 1<em>2^(deg++) + 0</em>2^(deg++). Repeat this for all of the 8 bits in the number that we read from input.bin. After that just write resultNum to file.</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;err.h&gt;
#include &lt;math.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdint.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;string.h&gt;
uint16_t myPow(uint16_t num,uint16_t deg);
uint16_t myPow(uint16_t num,uint16_t deg)
{
    uint16_t var=num;
    if(deg==0)
    {
            return 1;
    }
    for(int i = 1; i &lt; deg; i++)
    {
            num*=var;
    }
    return num;
}
int main (const int argc,const char * argv[])
{
    if(argc !=3)
    {
            errx(1,"insufficient args");
	}
    uint8_t mask = 1; // 00000001
    uint8_t num,masked;
    int fd1,res;
    fd1=open(argv[1],O_RDONLY);
    res=creat(argv[2], S_IRUSR | S_IWUSR);
    if(fd1==-1 || res == -1)
    {
            err(2,"Error opening one of the files");
    }
    ssize_t rdsz;
    while((rdsz=read(fd1,&amp;num,sizeof(num))) &gt; 0)
    {
            uint16_t resultNum=0;
            uint16_t deg=0,deg16=0;
            uint32_t magic = 0x699A;
            if(write(res,&amp;magic,sizeof(magic)) != sizeof(magic))
            {
                    err(5,"Error writing resultNum to result file");
            }
            while(deg &lt;= 7)
            {
                    masked=num&amp;mask;
                    if(masked == 1)
                    {
                            deg16++;
                            resultNum+=myPow(2,deg16);
                            deg16++;
                            //printf("bit is 1:  %u %u\n",deg16,resultNum);
                    }
                    else
                    {
                            resultNum+=myPow(2,deg16);
                            deg16+=2;
                            //printf("bit is 0:  %u %u\n",deg16, resultNum);
                    }
                    num&gt;&gt;=1;
                    deg++;
            }
            if(write(res,&amp;resultNum,sizeof(resultNum)) != sizeof(resultNum))
            {
                    err(5,"Error writing resultNum to result file");
            }
            //printf("my resultNum: %u\n",resultNum);
    }
    return 0;
}
</code></pre>
<h3 id="se-02-4">71. 2021-SE-02</h3>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;err.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdint.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;string.h&gt;
uint8_t myPow(uint8_t num,uint16_t deg);
uint8_t myPow(uint8_t num,uint16_t deg)
{
        uint8_t var=num;
        if(deg==0)
        {
                return 1;
        }
        for(int i = 1; i &lt; deg; i++)
        {
                num*=var;
        }
        return num;
}
int main (const int argc,const char * argv[])
{
        if(argc != 3)
        {
                errx(1,"insufficient args");
        }
        uint16_t encoded,mask=1;
        int fd1,res;
        fd1=open(argv[1], O_RDONLY);
        res=creat(argv[2],S_IRUSR | S_IWUSR);
        if(fd1 == -1)
        {
                err(2,"Error opening encoded file.");
        }
    ssize_t rdsz;
    // 10011001 10011010
    while((rdsz=read(fd1,&amp;encoded,sizeof(encoded)))&gt;0)
    {
            uint16_t currBitPair=8,deg=0;
            uint8_t resultNum,left,right;
            while(currBitPair &gt;0)
            {
                    right=encoded &amp; mask;
                    encoded&gt;&gt;=1;
                    left=encoded &amp; mask;
                    encoded&gt;&gt;=1;
                    if(left == 1 &amp;&amp; right == 0)
                    {
                            resultNum+=myPow(2,deg);
                            deg++;
                    }
                    else // 0 1
                    {
                            deg++;
                    }
                    currBitPair--;
            }
            if(write(res,&amp;resultNum,sizeof(resultNum)) != sizeof(resultNum))
            {
                    err(3,"Error writing the decoded num");
            }
    }
    return 0;
}
</code></pre>
<h3 id="in-01-2">73. 2022-IN-01</h3>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;err.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdint.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;string.h&gt;
struct HEADER_STR
{
        uint16_t magic;
        uint16_t fileType;
        uint32_t count;
};
struct LIST_STR
{
        uint8_t off_data;
        uint8_t off_out;
};
int myCmp(const void * left, const void * right);
int myCmp(const void * left, const void * right)
{
        const struct LIST_STR * leftP = (const struct LIST_STR *)left;
        const struct LIST_STR *rightP = (const struct LIST_STR *)right;
        return leftP-&gt;off_out - rightP-&gt;off_out;
}
int main (const int argc,const char * argv[])
{
        uint16_t outFileType=3;
        uint16_t outMagic=0x5A4D;
        if(argc != 4)
        {
                errx(1,"insufficient args");
        }
        int fdlist,fddata,fdout,fdtmp,fdtmp2;
        fdlist=open(argv[1], O_RDONLY);
        fddata=open(argv[2], O_RDONLY);
        fdout=creat(argv[3], S_IRUSR | S_IWUSR);
        fdtmp=creat("tmp", S_IRUSR | S_IWUSR);
        fdtmp2=creat("tmp2", S_IRUSR | S_IWUSR);
        if(fdlist == -1 || fddata == -1 || fdout == -1 || fdtmp == -1 || fdtmp2 == -1)
        {
                err(2, "Error opening/creating one of the files");
        }

    ssize_t rdsz,rdsz1;
    struct HEADER_STR listH,dataH,outH;
    if((rdsz=read(fdlist,&amp;listH,sizeof(listH))) &lt; 0 || (rdsz1=read(fddata,&amp;dataH,sizeof(dataH))) &lt; 0)
    {
            err(3,"Error reading header from data or list.");
    }

    outH.magic = outMagic;
    outH.fileType = outFileType;
    outH.count = listH.count;

    if(write(fdout,&amp;outH,sizeof(outH)) != sizeof(outH))
    {
            err(10,"error writing header of out to out.bin");
    }

    size_t ind=0,ind2=0;
    struct LIST_STR listStr;
    struct LIST_STR * list = malloc(listH.count/2); // todo::
    while((rdsz=read(fdlist,&amp;listStr,sizeof(listStr))) &gt; 0 &amp;&amp; ind &lt; listH.count/2)
    {
            list[ind++]=listStr;
    }

    qsort(list, ind, sizeof(listStr),myCmp); // first half is sorted and written
    for(size_t i = 0; i &lt; ind; i++)
    {
            if(write(fdtmp, &amp;list[i], sizeof(listStr)) != sizeof(listStr))
            {
                    err(4, "Error writing list str to tmp file");
            }
    }

    while((rdsz=read(fdlist,&amp;listStr,sizeof(listStr))) &gt; 0)
    {
            list[ind2++]=listStr;
    }
    qsort(list, ind2, sizeof(listStr),myCmp);
    lseek(fdtmp, 0, SEEK_SET);

    size_t currInd=0;
    while((rdsz=read(fdtmp,&amp;listStr,sizeof(listStr))) &gt; 0 &amp;&amp; currInd &lt; ind2)
    {
            struct LIST_STR arrList = list[currInd];
            if(listStr.off_out &lt; arrList.off_out)
            {
                    if(write(fdtmp2, &amp;listStr, sizeof(listStr)) != sizeof(listStr))
                    {
                            err(5,"Error writing listStr from file to fdtmp2");
                    }
            }
            else
            {
                    if(write(fdtmp2,&amp;arrList, sizeof(arrList)) != sizeof(arrList))
                    {
                            err(6,"Error writing arrList from array to fdtmp2");
                    }
                    currInd++;
                    lseek(fdtmp,-1,SEEK_CUR);
            }
    }

    while(rdsz &gt; 0 &amp;&amp; (rdsz=read(fdtmp,&amp;listStr, sizeof(listStr))) &gt; 0)
    {
            if(write(fdtmp2,&amp;listStr, sizeof(listStr)) != sizeof(listStr))
            {
                    err(6,"Error writing rest of listStr from file to fdtmp2");
            }
    }

    while(currInd &lt; ind2)
    {
            if(write(fdtmp2, &amp;list[currInd],sizeof(list[currInd])) != sizeof(list[currInd]))
            {
                    err(7,"Error writing the rest of list to fdtmp2");
            }
    }

    while((rdsz=read(fdtmp2, &amp;listStr, sizeof(listStr))) &gt; 0)
    {
            lseek(fddata, listStr.off_data, SEEK_SET);
            uint32_t dataNum;
            ssize_t rdsz2;
            if((rdsz2=read(fddata,&amp;dataNum,sizeof(dataNum))) &lt; 0)
            {
                    err(8,"Error reading dataNum from data.bin");
            }
            uint64_t outNum=(uint64_t)dataNum;
            if(write(fdout,&amp;outNum,sizeof(outNum)) != sizeof(outNum))
            {
                    err(9,"ERror writing outNum to out.bin");
            }
    }

    free(list);
    return 0;
}
</code></pre>
<h3 id="se-01-5">74. 2022-SE-01</h3>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;err.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdint.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;string.h&gt;
struct DataHeader
{
        uint32_t magic;
        uint32_t count;
};
struct ComparatorHeader
{
        uint32_t magic1;
    uint16_t magic2;
        uint16_t reserved;
        uint64_t count;
};
struct ComparatorData
{
        uint16_t type;
        uint16_t reserved1,reserved2,reserved3;
        uint32_t offset1;
        uint32_t offset2;
};
int main (const int argc,const char * argv[])
{
    if(argc!=3)
    {
            errx(1,"insufficient args");
    }

    int fddata,fdcomp;
    fddata=open(argv[1],O_RDONLY);
    fdcomp=open(argv[2],O_RDONLY);
    if(fddata == -1 || fdcomp == -1)
    {
            err(2,"Error opening one of the files");
    }

    struct DataHeader dataH;
    struct ComparatorHeader compH;
    struct ComparatorData compData;
    ssize_t rdsz;

    if((rdsz=read(fddata,&amp;dataH,sizeof(dataH))) &lt;0 || (rdsz=read(fdcomp,&amp;compH,sizeof(compH))) &lt;0)
    {
            err(3,"Error reading dataHeader or compHeader");
    }

    if(dataH.magic != 0x21796F4A || compH.magic1 != 0xAFBC7A37 || compH.magic2 != 0x1C27)
    {
            errx(4,"Incosistent files");
    }

    uint64_t data;
    size_t dataInd=0;
    uint64_t * dataArr=malloc(dataH.count);
    while((rdsz=read(fddata,&amp;data, sizeof(data))) &gt;0)
    {
            dataArr[dataInd++]=data;
    }

    close(fddata);
    fddata=open(argv[1], O_WRONLY | O_TRUNC);
    if(fddata == -1)
    {
            err(5, "Failed opening/truncating data.bin");
    }

    if(write(fddata, &amp;dataH, sizeof(dataH)) != sizeof(dataH))
    {
            err(6, "Error writing header of dataH to data.bin");
    }

    while((rdsz=read(fdcomp,&amp;compData, sizeof(compData))) &gt; 0)
    {
            if(compData.reserved1 != 0 || compData.reserved2 != 0 || compData.reserved3 != 0 || compData.type &gt; 1)
            {
                    errx(7,"Incosistent files");
            }

            uint32_t off1 = compData.offset1-64,off2=compData.offset2-64;
            if(compData.type == 0)
            {
                    if(dataArr[off1] &gt; dataArr[off2])
                    {
                            uint64_t tmp = dataArr[off1];
                            dataArr[off1]= dataArr[off2];
                            dataArr[off2]= tmp;
                    }
            }
            else
            {
                    if(dataArr[off1] &lt; dataArr[off2])
                    {
                            uint64_t tmp = dataArr[off1];
                            dataArr[off1]= dataArr[off2];
                            dataArr[off2]= tmp;
                    }
            }
    }

    for(size_t i =0; i &lt; dataH.count; i++)
    {
            if(write(fddata,&amp;dataArr[i],sizeof(dataArr[i])) != sizeof(dataArr[i]))
            {
                    err(8,"Error writing the correct data to data.bin");
            }
    }
    free(dataArr);
    close(fddata);
    close(fdcomp);
    return 0;
}
</code></pre>
</div>
</body>

</html>
